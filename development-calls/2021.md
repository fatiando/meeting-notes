# Fatiando Development Calls 2021

ðŸ“± **Join the video call:** https://jitsi.softwareunderground.org/FatiandoATerraMeetings

ðŸ“œ **Meeting notes:** https://hackmd.io/@fatiando/development-calls-2021

ðŸ—„ï¸ **Archive:** https://github.com/fatiando/meeting-notes

ðŸ“… **Shared calendar:** http://calendar.fatiando.org

* Public iCalendar link: https://calendar.google.com/calendar/ical/2brp0bfvui24atsvb0ridafk50%40group.calendar.google.com/public/basic.ics

> **IMPORTANT**: Everyone is required to follow our 
> [Code of Conduct](https://github.com/fatiando/contributing/blob/master/CODE_OF_CONDUCT.md)
> when participating in the Fatiando community. Please review it carefully.

Development calls are **open to everyone**! Here we discuss routine project development: implementation details, code refactoring, maintenance tasks, documentation, etc. Discussions tend to be **more technical** than our Community Calls.

**Everyone is encouraged to edit the notes below.**

--------------------------------------------------------------

## 2021-07-16

**Time:** 14:00 (UTC)

**Participants** (please add your name)

* Leo Uieda
* Santi Soler

**Discussion points:**

* Leo was invited to write a short news article for the Brazilian Geophysical Society about Fatiando (in Portuguese). Have to do this by August and will send around for some feedback.
* Split up the `verde.ScipyGridder` into 3:
    * `vd.NearestNeighbors`: NN interpolation using `cKDTree` or `pykdtree`. Option to average K nearest neighbors. Include a search radius as well (`max_distance` in the `query` method).
    * `vd.LinearGridder` and `vd.CubicGridder`: Wrap the scipy methods and add the option `extrapolate` (default to `True`) to fill NaNs with nearest neighbors (default to 1 neighbor).
    * Can help move the focus away from Green's functions.
    * Add these classes then deprecate `ScipyGridder` to remove in 2.0.0.
* Roadmap for Harmonica
    * Focus for v0.3:
        * MVP: Processing raw gravity -> Residual grid -> transformations (FFT or EQL)
            * Restrict to Cartesian
        * Missing components:
            * EQLHarmonicBoost
            * Finish FFT filters (explain using gridded data):
                * Upward derivative (horizontal uses xarray)
                * Upward continuation (optional)
                * Total gradient amplitude (optional)
                * Total horizontal gradient (optional)
            * Theory:
                * Coordinate systems
                * Gravity disturbance and corrections explained
            * Tutorials:
                * Basically what we did for Transform (but maybe split it up)
                * Tutorial on transformations (with EQLs and FFT and when to use which)
    * Documentation!
        * Good docstrings but no tutorials
        * Santi's thesis will be a good basis for the theory
        * What is the workflow and the theory
    * Wishlist:
        * Tesseroids with variable density
        * Gradient boosted EQLs
        * FFT solutions: derivatives, TGA, reduction to the pole, upward continuation
        * IGRF: 
            * Coeffs are here: https://www.ngdc.noaa.gov/IAGA/vmod/igrf.html
            * Calculation is actually really easy
            * No point in wrapping a fortran 77 code
            * Can use outputs from the fortran to test
            * Need to derive the equations for the x, y, z components of the SH model

## 2021-07-02

**Time:** 14:00 (UTC)

**Participants** (please add your name)

* Santi Soler
* Lu Li

**Discussion points:**

* Some test for `xrft`: https://nbviewer.jupyter.org/github/LL-Geo/PFToolbox/blob/master/xrft_note.ipynb
    * Looks like we can direct use `fft` and ignore `dft`
    * We can save the coordinate information from original grid, and pass it back for the `ifft`
* Santi opened a PR on `xrft` for padding grid and coordinates: https://github.com/xgcm/xrft/pull/158
    * They asked us to upstream the pad_coordinates to xarray
    * Start with supporting only padding through number of points (we can work on lenght of coordinates in the future)
* Set up a Bot for reminders on Fatiando calls
    * One day before
    * One hour before
    * Tweet reminders

## 2021-06-25

**Time:** 14:00 (UTC)

**Participants** (please add your name)

* Leo
* Santiago
* Agustina
* Lu

**Discussion points:**

* Interaction with `xrft`:
    * Santi has opened an Issue to start engaging the `xrft` community: [xrft #154](https://github.com/xgcm/xrft/issues/154)
        * Naming of the default function for applying FFT: `fft` vs `dft`
            * Devs agree and seem to favour `fft`
            * Requires improvement of docs around true_phase and true_amplitude
        * Coordinates shifts: `lag` argument in `fft` and including `lag` in the Fourier transform
        * Padding implementation:
            * They asked Santi to open a PR in `xrft` with a padding implementation
            * Wouldn't be better to enhance the `xarray.DataArray` pad for also pad the coordinates if they are evenly spaced?
            * Limitation of current padding in xarray:
                * By default, pads the coordinates with nans
                * Make sense because there is no way to know what the coordinates are if the spacing is irregular
                * Could do it if the coordinates are regular
            * Pitch:
                * Implement the padding coordinates in xrft for now
                * Basically check for nans and then add coordinates as needed
                * When it's implemented in xarray, we can shift to using that instead

**Quick updates:**

* Leo started preparing some data for RockHound to use as new sample data in our docs:
    * [Bathymetry from the Caribbean](https://nbviewer.jupyter.org/github/fatiando/rockhound-data/blob/bathymetry/bathymetry-caribbean/prepare.ipynb)
    * [Global gravity and topography](https://nbviewer.jupyter.org/github/fatiando/rockhound-data/blob/global_grids/gravity-topography-global/prepare.ipynb)


## 2021-06-18

**Time:** 14:00 (UTC)

**Participants** (please add your name)

* Santi Soler
* Agustina Pesce
* Leo Uieda

**Discussion points:**

* Reconcile the Harmonica and Verde gridding API?
    * The EQLHarmonic and Spline APIs are slightly different:
        * `.grid` takes the extra `upward` coordinate in EQLHarmonic
    * Done for a more intuitive and descriptive interface
    * But it means we can't use anything that relies on the Verde API, like `vd.Chain`, `vd.Vector`, and the proposed `vd.Derivative`.
        * Actually, we can but the `Chain.grid` and `EQLHarmonica.grid` methods are different, making it a bit awkward to use.
    * Is there a way to keep the `upward` argument and make the APIs compatible again (even if it means changing the Verde API)?
    * PROPOSAL:
        * Deprecate `region`, `shape`, `shaping` from the `grid` method, make it only take the actual grid coordinates, either from `vd.grid_coordinates` or from an `xarray` object (as 1d arrays).
        * Add a new property to gridders that documents the number of dimensions (`n_dims`?)
        * Make the `Chain` to inherit the maximum `n_dim` from the gridders in the chain
        * Add a `grid` method to `Chain` that complains if the passed coordinates are less than `n_dim`
        * Implement this in a `dev-2.0` branch that will be merged before major release
* Invite people from `xrft` to next meeting

## 2021-06-11

**Time:** 14:00 (UTC)

**Participants** (please add your name)

* Leo 
* Santi Soler
* Lu
* Andrea
* Agustina

**Quick updates**

* Pooch is using the `sphinx-book-theme` and trying out a new docs layout: [#237](https://github.com/fatiando/pooch/pull/237)
* Pooch PR to download from Zenodo and figshare: https://github.com/fatiando/pooch/pull/241
    * Will be useful for refactoring RockHound into our sample data repository
    * Can put every dataset in the same Zenodo/figshare archive and download individual files

**Longer discussion**

* Frequency-domain filters in Harmonica: [#238](https://github.com/fatiando/harmonica/pull/238)
    * Two type of functions:
        * Filters: work only in frequency domain. I would like to create a `filter` module where they should live.
            * Takes FFT from xrft and outputs still in frequency domain
            * Mostly for internal use but can be used by others as well
        * Filters will be public but not the wrapped FFT functions
        * Transform and processing functions (derivatives, upward continuation, RTP, etc). 
            * Their arguments and outputs are always in spatial domain.
            * They call xrft, use the filters, and then inverse the transform
    * We should engage with `xrft` and discuss some things regarding their implementation.
        * What `true_amplitude` and `true_phase` mean?
        * Why `lag` is not working properly?
            * Inverse transform removes the absolute value of the coordinates so they are centered at zero
            * Need to shift the coordinates in our own code
            * The `lag` seems like it does this but doesn't work for some reason.
            * Check if the coordinates of input and output match to see if we need to shift
        * Why having `dft` and `fft`? What are the differences between them?
        * Santi may have found some bugs in the phase
        * Engaging with them instead of wrapping everything locally is better for the community as a whole
        * Open an issue to start the conversation
    * Derivatives:
        * Should we add the option to choose between finite difference or FFT derivative for easting and northing?
            * The finite difference can be achieved by `xr.differentiate`.
            * For now, remove the horizontal ones from the PR and leave just the vertical
            * In the docs, use xarray for the horizontal derivatives
        * How about using an argument to specify the direction?
            * Better to have 1 function in the docs
            * But can't auto-complete the direction names in notebooks
        * Directional derivatives could be a usecase for FFT based horizontal derivatives
            * Lu will provide a reference/use case for this that we could base the implementation on
            * Could also be done with finite-differences 
            * The best solution might be: ? $$ F(DD)=F(g)*(u*i*sin(\theta)+v*i*cos(\theta))$$ So that we could combine the horizontal derivatives with directional derivatives together by different angle
            * Ref 1: Hang, N. T. T. (2017). Application of directional derivative method to determine boundary of magnetic sources by total magnetic anomalies. VIETNAM JOURNAL OF EARTH SCIENCES, 39(4), 360-375.
            * Ref 2: Stewart, I. C., & Miller, D. T. (2018). Directional tilt derivatives to enhance structural trends in aeromagnetic grids. Journal of Applied Geophysics, 159, 553-563.
        * Need to engage with xarray on their padding function.
            * It doesn't set coordinates (just NaNs) for the padded region
            * This makes xrft angry
            * Not trivial to implement in xarray since their Datasets aren't necessarily regular grids